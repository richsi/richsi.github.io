<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="richsi">
<meta name="dcterms.date" content="2025-01-06">

<title>Machine Learning - Tom Mitchell – richsi.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-e8fb9d25728d58bfeac61b497e4a6629.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-57a92833092fd6dc0d7710b6bdfff9c5.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-15fa106bca5cd15c786ba48bc3bd94a6.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-f219526d42f01ba59e9b63b8d0bc0fb9.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">richsi.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/richsi"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/richhsi/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Machine Learning - Tom Mitchell</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Book</div>
                <div class="quarto-category">Notes</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>richsi </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 6, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="2">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a>
  <ul class="collapse">
  <li><a href="#well-posed-learning-problems" id="toc-well-posed-learning-problems" class="nav-link" data-scroll-target="#well-posed-learning-problems">Well-Posed Learning Problems</a></li>
  <li><a href="#designing-a-learning-system" id="toc-designing-a-learning-system" class="nav-link" data-scroll-target="#designing-a-learning-system">Designing a Learning System</a></li>
  </ul></li>
  <li><a href="#decision-tree-learning" id="toc-decision-tree-learning" class="nav-link" data-scroll-target="#decision-tree-learning">Decision Tree Learning</a>
  <ul class="collapse">
  <li><a href="#appropriate-problems-for-decision-tree-learning" id="toc-appropriate-problems-for-decision-tree-learning" class="nav-link" data-scroll-target="#appropriate-problems-for-decision-tree-learning">Appropriate Problems for Decision Tree Learning</a></li>
  <li><a href="#the-basic-decision-tree-learning-algorithm" id="toc-the-basic-decision-tree-learning-algorithm" class="nav-link" data-scroll-target="#the-basic-decision-tree-learning-algorithm">The Basic Decision Tree Learning Algorithm</a></li>
  <li><a href="#inductive-bias-in-decision-tree-learning" id="toc-inductive-bias-in-decision-tree-learning" class="nav-link" data-scroll-target="#inductive-bias-in-decision-tree-learning">Inductive Bias in Decision Tree Learning</a></li>
  <li><a href="#issues-in-decision-tree-learning" id="toc-issues-in-decision-tree-learning" class="nav-link" data-scroll-target="#issues-in-decision-tree-learning">Issues in Decision Tree Learning</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Machine learning is inherently a multidisciplinary field. It draws on results from artificial intelligence, probability, statistics, complexity theory, and many more.</p>
<hr>
<section id="well-posed-learning-problems" class="level3">
<h3 class="anchored" data-anchor-id="well-posed-learning-problems">Well-Posed Learning Problems</h3>
<blockquote class="blockquote">
<p><strong>Definition</strong>: A computer program is said to <strong>learn</strong> from experience <span class="math inline">\(E\)</span> with respect to some class of tasks <span class="math inline">\(T\)</span> and performance measure <span class="math inline">\(P\)</span>, if its performance at tasks in <span class="math inline">\(T\)</span>, as measured by <span class="math inline">\(P\)</span>, improves with experience <span class="math inline">\(E\)</span>.</p>
</blockquote>
<p><strong>Robot Driving Learning Problem:</strong></p>
<ul>
<li>Task <span class="math inline">\(T\)</span>: driving on public four-lane highways using vision sensors</li>
<li>Performance measure <span class="math inline">\(P\)</span>: average distance traveled before an error</li>
<li>Training experience <span class="math inline">\(E\)</span>: a sequence of images and steering commands recorded while observing a human driver</li>
</ul>
<hr>
</section>
<section id="designing-a-learning-system" class="level3">
<h3 class="anchored" data-anchor-id="designing-a-learning-system">Designing a Learning System</h3>
<p>Consider designing a program to learn to player checkers. Assume no external teacher.</p>
<ul>
<li>Task <span class="math inline">\(T\)</span>: playing checkers</li>
<li>Performance measure <span class="math inline">\(P\)</span>: percent of games won</li>
<li>Training experience <span class="math inline">\(E\)</span>: games played against itself</li>
</ul>
<p><strong>Choosing the Training Experience</strong></p>
<ul>
<li>One key attribute is whether the training experience provides direct or indirect feedback regarding the choices made by the performance system
<ul>
<li><em>Direct</em> training examples can consist of individual checker board states and the correct move for each</li>
<li><em>Indirect</em> training examples may consist of move sequences and their final outcomes</li>
</ul></li>
<li>A second important attribute of the training experience is the degree to which the learner controls the sequence of training examples</li>
<li>A third important attribute is how well it represents the distribution of examples over which the final system performance <span class="math inline">\(P\)</span> must be measured
<ul>
<li>In practice, it is often necessary to learn from a distribution of examples that is somewhat different from those on which the final system will be evaluated</li>
<li>Most current theory of machine learning rests on the assumption that the distribution of training examples is identical to the distribution of test examples</li>
</ul></li>
</ul>
<p><strong>Choosing the Target Function</strong></p>
<p>The target function will determine what type of knowledge will be learned and how it will be used by the performance program. Let us assume a target function <span class="math inline">\(V\)</span> that maps any legal board state from the set <span class="math inline">\(B\)</span> to some real value. We intend for this target function <span class="math inline">\(V\)</span> to assign higher scores to better board states</p>
<p>Let us define the target value <span class="math inline">\(V(b)\)</span> for an arbitrary board state <span class="math inline">\(b\)</span> in <span class="math inline">\(B\)</span>, as follows:</p>
<ol type="1">
<li>if <span class="math inline">\(b\)</span> is a final board state that is won, then <span class="math inline">\(V(b)\)</span> = 100</li>
<li>if <span class="math inline">\(b\)</span> is a final board state that is lost, then <span class="math inline">\(V(b)\)</span> = -100</li>
<li>if <span class="math inline">\(b\)</span> is a final board state that is drawn, then <span class="math inline">\(V(b)\)</span> = 0</li>
<li>if <span class="math inline">\(b\)</span> is not a final state in the game, then <span class="math inline">\(V(b) = V(b')\)</span> where <span class="math inline">\(b'\)</span> is the best final board state that can be achieved starting from <span class="math inline">\(b\)</span> and playing optimally until the end of the game</li>
</ol>
<p>However, searching for the optimal line of play, all the way until the end of the game, is not efficiently computable. The goal of learning in this case is to discover an <em>operational</em> description of <span class="math inline">\(V\)</span>. A description that can be used by the checkers-playing program to evaluate states and select moves within realistic time bounds. Thus, we have reduced the learning task in this case to the problem of discovering an <em>operational description of the ideal target function</em> <span class="math inline">\(V\)</span>.</p>
<p><strong>Choosing a Representation for the Target Function</strong></p>
<p>After specifying the ideal target function <span class="math inline">\(V\)</span>, we must choose a representation that the learning program will use to describe the function <span class="math inline">\(\hat{V}\)</span> that it will learn. The choice of representation involves a crucial tradeoff. On one hand, we wish to pick a very expressive representation to allow represnting as close an approximation as possible to the target function <span class="math inline">\(V\)</span>. On the other hand, the more expressive the representation, the more training data the program will require in order to choose among the alternative hypotheses it can represent.</p>
<p><strong>Choosing a Function Approximation Algorithm</strong></p>
<p>While it is easy to assign a value to board states that correspond to the end of the game, it is less obvious how to assign training values to the <em>intermediate</em> board states that occur before the game’s end. The rule for estimating training values is summarized as</p>
<blockquote class="blockquote">
<p><strong>Rule for estimating training values:</strong> <span class="math display">\[
V_{train}(b) \leftarrow \hat{V}(Successor(b))
\]</span></p>
</blockquote>
<p><span class="math inline">\(\hat{V}\)</span> denotes the learner’s current approximation to <span class="math inline">\(V\)</span> and <span class="math inline">\(Successor(b)\)</span> denotes the next board state following <span class="math inline">\(b\)</span>. Iteratively estimating training values based on estimates of successor state values can be proven to converge toward perfect estimates of <span class="math inline">\(V_{train}\)</span>.</p>
<p><strong>Adjusting the Weights</strong></p>
<p>First, define the <em>best fit</em> to the training data. One common approach is to define the best hypothesis, or set of weights, which minimizes the squared error <span class="math inline">\(E\)</span> between training (real) values and values predicted by hypothesis <span class="math inline">\(\hat{V}\)</span>.</p>
<p><span class="math display">\[
E \equiv \sum_{\langle b, V_{train}(b) \rangle \in\ training\ examples} (V_{train}(b) - \hat{V}(b))^2
\]</span></p>
<p>Thus, we seek the weights, or equivalently the <span class="math inline">\(\hat{V}\)</span>, that minimizes <span class="math inline">\(E\)</span> for the observed training examples. Many algorithms will incremently refine the weights as new training examples become avavilable and become rebust to errors in these estimated training values. One example is least mean squares (LMS), which performs stochastic gradient-descent search through the space of hypotheses (weight values) to minimize the squared error <span class="math inline">\(E\)</span>.</p>
<blockquote class="blockquote">
<p><strong>LMS weight update rule</strong></p>
<p>For each training example <span class="math inline">\(\langle b, V_{train}(b)\rangle\)</span></p>
<ul>
<li>Use the current weights to calculate <span class="math inline">\(\hat{V}(b)\)</span></li>
<li>For each weight <span class="math inline">\(w_i\)</span>, update it as <span class="math inline">\(w_i \leftarrow w_i + \eta (V_{train}(b) - \hat{V}(b))x_i\)</span></li>
</ul>
</blockquote>
<p>Here, <span class="math inline">\(\eta\)</span> is a small constant (e.g., 0.1) that moderates the size of the weight update. For a deeper intuitive understanding, notice that when the error <span class="math inline">\((V_{train}(b) - \hat{V}(b))\)</span> is zero, the weights are not changed. However, if the is positive, that means <span class="math inline">\(\hat{V}(b)\)</span> is too small and the weight is increased in proportion to the value of its corresponding feature.</p>
<hr>
</section>
</section>
<section id="decision-tree-learning" class="level1">
<h1>Decision Tree Learning</h1>
<p>Decision tree (DT) learning is one of the most commonly used methods for inductive inference. It is a method for approximating discrete-valued target functions that is robust to noisy data and capable of learning disjunctive expressions.</p>
<section id="decision-tree-representation" class="level4">
<h4 class="anchored" data-anchor-id="decision-tree-representation">Decision Tree Representation</h4>
<p>DTs classify instances by sorting a tree from the root to some leaf node, which provides classification of the instance. Each node in the tree specifies some <em>attribute</em> of the instance. Each path from the tree root to a leaf corresponds to a conjunction of attribute tests</p>
<hr>
</section>
<section id="appropriate-problems-for-decision-tree-learning" class="level3">
<h3 class="anchored" data-anchor-id="appropriate-problems-for-decision-tree-learning">Appropriate Problems for Decision Tree Learning</h3>
<p>DT Learning is generally best suited to problems with the following characteristics:</p>
<ul>
<li><em>Instances are represented by attribute-value pairs.</em> Instances are described by a fixed set of attributes (e.g., <em>Temperature</em>) and their values (e.g., <em>Hot</em> or <em>72F</em>)</li>
<li><em>The target function has discrete output values</em></li>
<li><em>Disjunctive descriptions may be required.</em> DT naturally represent disjunctive expressions</li>
<li><em>The training data may contain errors.</em> DT learning methods are robust to errors, both errors in classifications of the training examples and errors in the attribute values that describe these examples</li>
<li><em>The training data may contain missing attribute values.</em> DT methods can be used even when some training examples have unknown values</li>
</ul>
<hr>
</section>
<section id="the-basic-decision-tree-learning-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="the-basic-decision-tree-learning-algorithm">The Basic Decision Tree Learning Algorithm</h3>
<p>Most algorithms that have been developed for learning DT trees are variations on a core algorithm that employs a top-down, greedy search through the space of possible DTs. The algorithms we will look at is ID3 (Quinlan 1986).</p>
<p><strong>How Does ID3 Work?</strong></p>
<ul>
<li>Learns DTs by constructing them top-down by evaluating each instance attribute to determine how well it classifies the training examples</li>
<li>The best attribute is selected and used as the test at the root node of the tree</li>
<li>A descendant of the root node is then created for each possible value of this attribute, and the training examples are sorted to the appropriate descendant node</li>
</ul>
<p>This forms a greedy search for an acceptable DT, in which the algorithm never backtracks to reconsider earlier choices.</p>
<p><strong>Which Attribute Is the Best Classifier?</strong></p>
<p>We would like to select the attribute that is most useful for classifying examples. We define a statistical property, called <em>information gain</em>, as a measure for how well a given attribute separates the training examples according to their target classification.</p>
<p>To precisely define information gain, we use <em>entropy</em>. Entropy chracterizes the (im)purity of an arbitrary collection of examples. Given a collection <span class="math inline">\(S\)</span>, containing positive and negative examples, the entropy of <span class="math inline">\(S\)</span> relative to boolean classification is</p>
<p><span class="math display">\[
Entropy(S) \equiv -p_+ log_2 p_+ - p_- log_2 p_-
\]</span></p>
<p>where <span class="math inline">\(p_+\)</span> is the proportion of positive examples in <span class="math inline">\(S\)</span> and <span class="math inline">\(p_-\)</span> is the proportion of negative examples in <span class="math inline">\(S\)</span>. We define 0 log 0 to be 0 in all calculations involving entropy. For example,</p>
<p><span class="math display">\[
Entropy([9+, 5-]) = -(9/14)log_2 (9/14) - (5/14)log_2 (5/14) = 0.940
\]</span></p>
<p>Notice entropy is 0 if all members of <span class="math inline">\(S\)</span> belongs to the same class. Entropy will be 1 when the collection contains an equal number of positive and negative samples.</p>
<p align="center">
<img src="images/entropy_figure.png" alt="Entropy Figure" style="max-width: 70%; height:auto;">
</p>
<ul>
<li>Entropy of <span class="math inline">\(S\)</span> relative to <span class="math inline">\(c\)</span> different target attributes is defined as</li>
</ul>
<p><span class="math display">\[
Entropy(S) \equiv \sum_{i=1}^{c} -p_i log_2 p_i
\]</span></p>
<ul>
<li>Information gain measures the expected reduction in entropy. The information gain, <span class="math inline">\(Gain(S, A)\)</span> of an attribute <span class="math inline">\(A\)</span>, relative to a collection of examples <span class="math inline">\(S\)</span>, is defined as</li>
</ul>
<p><span class="math display">\[
Gain(S, A) \equiv Entropy(S) - \sum_{v\in Values(A)} \frac{|S_v|}{|S|} Entropy(S_v)
\]</span></p>
<ul>
<li>For example, suppose <span class="math inline">\(S\)</span> is a collection of days described by the attributes including <span class="math inline">\(Wind\)</span>, which can have the values <span class="math inline">\(Weak\)</span> or <span class="math inline">\(Strong\)</span>. The information gain due to sorting the original 14 examples by the attribute <span class="math inline">\(Wind\)</span> may be calculated as</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
Values(Wind) &amp;= Weak, Strong\\
S &amp;= [9+, 5-] \\
S_{Weak} &amp;\leftarrow [6+, 2-]\\
S_{Strong} &amp;\leftarrow [3+, 3-]\\
Gain(S, Wind) &amp;= Entropy(S) - \sum_{v\in(Weak, Strong)} \frac{|S_v|}{|S|} Entropy(S_v) \\
&amp;= Entropy(S) - (8/14)Entropy(S_{Weak})\\
&amp;\quad- (6/14)Entropy(S_{Strong})\\
&amp;= 0.940 - (8/14)0.811 - (6/14)1.00\\
&amp;=0.048
\end{aligned}
\]</span></p>
<p><strong>Hypothesis Space Search in Decision Tree Learning</strong></p>
<ul>
<li>ID3 in its pure form performs no backtracking in its search. Therefore, it is susceptible to the usual risks of hill-climbing search without backtracking: converging to locally optimal solutions that are not globally optimimal.</li>
<li>ID3 uses all training examples at each step in the search to make statistically based decisions regarding how to refine its current hypothesis. One advantage of using statistical properities (e.g., information gain) is that the resulting search is much less sensitive to errors in individual training examples.</li>
</ul>
<hr>
</section>
<section id="inductive-bias-in-decision-tree-learning" class="level3">
<h3 class="anchored" data-anchor-id="inductive-bias-in-decision-tree-learning">Inductive Bias in Decision Tree Learning</h3>
<p>Inductive bias is the set of assumptions that, together with the training data, deductively justify the classifications assigned by the learner to future instances. ID3 chooses the first acceptable tree it encounters in its simple-to-complex, hill-climbing search through the space of possible trees. It selects in favor of shorter trees over longer ones, and selects trees that place the attributes with highest information gain closest to the root.</p>
<p><strong>Restriction Biases and Preference Biases</strong></p>
<p>The inductive bias of ID3 follows from its <em>search strategy</em>, whereas the inductive bias of Candidate-Elimination algorithm follows from the definition of its <em>search space</em> (incomplete hypothesis space).</p>
<p>Thus, ID3 demonstrates a preference bias for shorter hypotheses. In contrast, the bias of Candidate-Elimination algorithm is in the form of a categorial restriction on the set of hypothesis considered. This form of bias is called <em>restriction bias</em>.</p>
<p>Typically, preference bias is more desirable as it allows the learner to work within a complete hypothesis space that is assured to contain the unknown target function.</p>
<p><strong>Why Prefer Short Hypotheses?</strong></p>
<blockquote class="blockquote">
<p><strong>Occam’s razor:</strong> Prefer the simplest hypothesis that fits the data.</p>
</blockquote>
<p>Why? One argument is that because there are fewer short hypotheses than long ones (based on straightforward combinational arguments), it is less likely that one will find a short hypothesis that coincidentally fits the training data. In contrast, there are often many very complex hypotheses that fit the current training data but fail to generalize correctly to subsequent data.</p>
<p>Problems with Occam’s razor:</p>
<ul>
<li>There are many small sets of hypotheses that one can define. Why should we believe that the small set of hypotheses consisting of decision trees with <em>short descriptions</em> should be any more relevant than the multitude of other small sets of hypotheses that we might define before?</li>
<li>The size of a hypothesis is determined by the particular representation used <em>internally</em> by the learner. Two learners using different internal representations could therefore arrive at different hypotheses, both justifying their contradictory conlcusions by Occam’s razor.</li>
<li>Occam’s razor will product two different hypotheses from the same training examples when it is applied by two learners that perceive these examples in terms of different internal representations.</li>
</ul>
<hr>
</section>
<section id="issues-in-decision-tree-learning" class="level3">
<h3 class="anchored" data-anchor-id="issues-in-decision-tree-learning">Issues in Decision Tree Learning</h3>
<p>Practical issues in learning decision trees include determining how deeply to grow the tree, handling continuous attributes, choosing an appropriate attribute selection measure, handling training data with missing attribute values, handling attributes with differing costs, and improving computational efficiency.</p>
<p><strong>Avoid Overfitting the Data</strong></p>
<blockquote class="blockquote">
<p><strong>Definition:</strong> Given a hypothesis space <span class="math inline">\(H\)</span>, a hypothesis <span class="math inline">\(h\in H\)</span> is said to <strong>overfit</strong> the training data if there exists some alternative hypothesis <span class="math inline">\(h'\in H\)</span>, such that <span class="math inline">\(h\)</span> has smaller error than <span class="math inline">\(h'\)</span> over the training examples, but <span class="math inline">\(h'\)</span> has a smaller error than <span class="math inline">\(h\)</span> over the entire distribution of instances.</p>
</blockquote>
<p>One way <em>overfitting</em> can occur is when the training examples contain random errors or noise. However, overfitting is also possible even when the training data are noise-free, especially when small numbers of examples are associated with leaf nodes.</p>
<p>Approaches to avoid overfitting in decision tree learning can be grouped into two classes:</p>
<ul>
<li>approaches that stop growing the tree earlier, before it reaches the point where it perfectly classifies (memorizes) the training data</li>
<li>approaches that allow the tree to overfit the data, and then post-prune the tree</li>
</ul>
<p>Approaches to determine the criterion to be used to determine the correct final tree size:</p>
<ul>
<li>Use a separate set of examples, distinct from the training examples, to evaluate the utility of post-pruning nodes from the tree</li>
<li>Use all the available data for training, but apply a statistical test to estimate whether expanding (or pruning) a particular node is likely to produce an improvement beyond the training set</li>
<li>Use an explicit measure of the complexity for encoding the training examples and the decision tree, halting growth of the tree when this encoding size is minimized</li>
</ul>
<p>The first approach is most commonly referred to as the <em>training and validation set</em> approach. The validation set is expected to provide a safety check against overfitting as it exhibits different fluctuations from the training set.</p>
<p><em>Reduced-error pruning</em> is an approach that considers each of the decision nodes in the tree to be candidates for pruning. Pruning a decision node consists of removing the subtree rooted at that node, making it a leaf node, and assigning it the most common classification of the training examples affiliated with that node. Nodes are removed only if the resulting pruned tree increases accuracy over the validation set.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = true;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>